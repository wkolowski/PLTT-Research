\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{xcolor}
\usetheme{Darmstadt}

\newcommand{\pipe}{\ |\ }

\newcommand{\Fun}[2]{#1 \to #2}
\newcommand{\Prod}[2]{#1 \times #2}
\newcommand{\Sum}[2]{#1 + #2}
\newcommand{\Unit}{\textbf{1}}
\newcommand{\Empty}{\textbf{0}}

\newcommand{\annot}[2]{(#1 : #2)}
\newcommand{\fun}[2]{\lambda #1. #2}
\newcommand{\app}[2]{#1\ #2}
\newcommand{\pair}[2]{(#1, #2)}
\newcommand{\outl}[1]{\texttt{outl}\ #1}
\newcommand{\outr}[1]{\texttt{outr}\ #1}
\newcommand{\inl}[1]{\texttt{inl}\ #1}
\newcommand{\inr}[1]{\texttt{inr}\ #1}
\newcommand{\case}[3]{\texttt{case}\ #1\ \texttt{of}\ (#2, #3)}
\newcommand{\unit}{\texttt{unit}}
\newcommand{\exfalso}[1]{\texttt{exfalso}\ #1}

\newcommand{\subst}[3]{#1\left[#2 := #3\right]}

\newcommand{\tyctx}[1]{\mathcolor{brown}{#1\ \texttt{ctx}}}

\newcommand{\fulltyping}[3]{#1 \vdash #2 : #3}
\newcommand{\typing}[2]{\fulltyping{\Gamma}{#1}{#2}}

\newcommand{\rulename}[1]{\textsc{\footnotesize{#1}}}
\newcommand{\infrule}[3][]{\displaystyle \frac{#2}{#3} \rulename{#1}}

\newcommand{\emptytypingctx}{\cdot}
\newcommand{\extend}[3]{#1, #2 : #3}
\newcommand{\extenddef}[4]{#1, #2 : #3 := #4}

\newcommand{\sidecond}[1]{#1}

\title{STLC with Hints\\A nice presentation of algorithmic typing}
\author{Wojciech Ko≈Çowski}

\begin{document}

\frame{\titlepage}

\section{Intro}

\begin{frame}{Intro}

In these slides, we will discover a nice presentation of an algorithm for type checking and (incomplete) type inference in the Simply Typed Lambda Calculus (STLC). But before we get the cake, STLC with Hints, we will taste four more variants of STLC to learn where our presentation is coming from:

\begin{itemize}
  \item Extrinsic STLC -- the most basic variant of STLC.
  \item Bidirectional STLC -- a nice variant of STLC with intuitive type checking and type inference algorithms.
  \item Intrinsic STLC -- an old an venerable variant, in which complete type inference is particularly easy.
  \item Dual Intrinsic STLC -- a crazy and obscure cousin of the above, in which type checking is particualrly easy.
\end{itemize}

\end{frame}

\begin{frame}{Types, contexts and judgements}

All variants of STLC presented in these slides will have the same types, contexts and declarative typing judgement. The only differences will be terms and possibly additional judgements.

\vspace{2em}

Types: \\
$A, B ::= \Fun{A}{B} \pipe \Prod{A}{B} \pipe \Sum{A}{B} \pipe \Unit \pipe \Empty$

\vspace{2em}

Typing contexts: \\
$\Gamma ::= \emptytypingctx \pipe \extend{\Gamma}{x}{A}$

\vspace{2em}

Judgements: \\
$\fulltyping{\Gamma}{e}{A}$

\end{frame}

\begin{frame}{Types, contexts and judgements -- explanations}

As for types, we have function types $\Fun{A}{B}$, (binary) product types $\Prod{A}{B}$, (binary) sum types $\Sum{A}{B}$, the unit type $\Unit$ and the empty type $\Empty$.

\vspace{2em}

Contexts are either empty (denote by the symbol $\emptytypingctx$) or they are another context $\Gamma$ extended with a typing declaration $x : A$ (denoted by $\extend{\Gamma}{x}{A}$).

\vspace{2em}

The judgement $\fulltyping{\Gamma}{e}{A}$ means that in context $\Gamma$, the term $e$ has type $A$.

\end{frame}

\section{Extrinsic}

\begin{frame}{Extrinsic STLC}

Extrinsic STLC is the simplest version of typed lambda calculus. The terms are the same as in untyped lambda calculus (with the addition of terms for products, sums, unit and empty). The typing relation takes the form of a type assignment system -- we describe which terms have which types, without worrying about issues such as implementation.

\end{frame}

\begin{frame}{Terms}

Terms: \\
$e ::=$ \\
\qquad $x \pipe$ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl{e} \pipe \outr{e} \pipe$ \\
\qquad $\inl{e} \pipe \inr{e} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Note: the terms are, in order of appearance, variables, functions, applications, pairs, left and right projections, left and right sum constructors, pattern matching for sums, a value of the unit type, and the eliminator for the empty type.

\end{frame}

\begin{frame}{Declarative typing -- basics}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma}}{\typing{x}{A}}$
\end{center}

\end{frame}

\begin{frame}{Declarative typing -- type-directed rules}

\begin{center}
  $\infrule{\fulltyping{\extend{\Gamma}{x}{A}}{e}{B}}{\typing{\fun{x}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\typing{f}{\Fun{A}{B}} \quad \typing{a}{A}}{\typing{\app{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\typing{a}{A} \quad \typing{b}{B}}{\typing{\pair{a}{b}}{\Prod{A}{B}}}$ \quad
  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\outl{e}}{A}}$ \quad
  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\outr{e}}{B}}$

  \vspace{2em}

  $\infrule{\typing{e}{A}}{\typing{\inl{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\typing{e}{B}}{\typing{\inr{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{e}{\Sum{A}{B}} \quad \typing{f}{\Fun{A}{C}} \quad \typing{g}{\Fun{B}{C}}}{\typing{\case{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{}{\typing{\unit}{\Unit}}$ \quad
  $\infrule{\typing{e}{\Empty}}{\typing{\exfalso{e}}{A}}$
\end{center}

\end{frame}

\begin{frame}{Metatheory}

Extrinsic STLC enjoys strong metatheoretical properties:

\begin{itemize}
  \item Confluence: if a term can be reduced to two different terms, these two can in turn be reduced to a common result.
  \item Termination: computation on well-typed terms always terminates.
  \item Type preservation: if we compute with a well-typed term, the result has the same type.
  \item Canonicity: in the empty context, normal forms are inductively generated from term constructors.
\end{itemize}

\vspace{1em}

Intuitively: given a well-typed term, in finite time it computes to another term of the same type which cannot compute anymore. In the empty context, we know the result of this computation must be a constructor.

\end{frame}

\begin{frame}{(Non)uniqueness of typing}

Despite these strong metatheoretic properties, Extrinsic STLC does not enjoy another important property: \textbf{uniqueness of typing}. This means that there are terms which can be assigned multiple types. For example, $\fun{x}{x}$ can be assigned the type $\Fun{A}{A}$ for any type $A$. The four culprits of this failure are lambda abstractions, sum constructors and exfalso.

\end{frame}

\section{Bidirectional}

\newcommand{\newterm}[1]{\mathcolor{green}{#1}}

\newcommand{\fullcheck}[3]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3}
\renewcommand{\check}[2]{\fullcheck{\Gamma}{#1}{#2}}

\newcommand{\fullinfer}[3]{#1 \vdash #2 \mathcolor{red}{\Rightarrow} #3}
\newcommand{\infer}[2]{\fullinfer{\Gamma}{#1}{#2}}

\begin{frame}{Bidirectional STLC}

Bidirectional STLC is a version of simply typed lambda calculus which focuses on a clean implementation of the type checker. The terms are as in Extrinsic STLC, but with the addition of a general type annotation construct that can appear anywhere and is not mandatory. The typing judgement is split into two: type checking and type inference, both of which are algorithmic, i.e. easily implementable.

\end{frame}

\begin{frame}{Terms and judgements}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \newterm{\annot{e}{A}} \pipe$ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl{e} \pipe \outr{e} \pipe$ \\
\qquad $\inl{e} \pipe \inr{e} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Note: green color marks terms which were not present in Extrinsic STLC.

\vspace{2em}

Judgements: \\
$\fullcheck{\Gamma}{e}{A}$ -- in context $\Gamma$, term $e$ checks against type $A$ ($A$ is an input) \\
$\fullinfer{\Gamma}{e}{A}$ -- in context $\Gamma$, term $e$ infers type $A$ ($A$ is an output)

\end{frame}

\begin{frame}{Declarative typing -- new rules}

\begin{center}
  $\infrule[Annot]{\typing{e}{A}}{\typing{\annot{e}{A}}{A}}$
\end{center}

\vspace{2em}

Note: the only rules shown are those which were not present in Extrinsic STLC.

\end{frame}

\begin{frame}{Bidirectional typing -- basics}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma}}{\infer{x}{A}}$

  \vspace{2em}

  $\infrule[Annot]{\check{e}{A}}{\infer{\annot{e}{A}}{A}}$

  \vspace{2em}

  $\infrule[Sub]{\infer{e}{B} \quad \sidecond{A = B}}{\check{e}{A}}$
\end{center}

\end{frame}

\begin{frame}{Bidirectional typing -- type-directed rules}

\begin{center}
  $\infrule{\fullcheck{\extend{\Gamma}{x}{A}}{e}{B}}{\check{\fun{x}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\infer{f}{\Fun{A}{B}} \quad \check{a}{A}}{\infer{\app{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\check{a}{A} \quad \check{b}{B}}{\check{\pair{a}{b}}{\Prod{A}{B}}}$ \quad
  $\infrule{\infer{e}{\Prod{A}{B}}}{\infer{\outl{e}}{A}}$ \quad
  $\infrule{\infer{e}{\Prod{A}{B}}}{\infer{\outr{e}}{B}}$

  \vspace{2em}

  $\infrule{\check{e}{A}}{\check{\inl{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\check{e}{B}}{\check{\inr{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\infer{e}{\Sum{A}{B}} \quad \check{f}{\Fun{A}{C}} \quad \check{g}{\Fun{B}{C}}}{\check{\case{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{}{\check{\unit}{\Unit}}$ \quad
  $\infrule{\check{e}{\Empty}}{\check{\exfalso{e}}{A}}$
\end{center}

\end{frame}

\begin{frame}{Bidirectional typing -- additional rules}

\begin{center}
  $\infrule{}{\infer{\unit}{\Unit}}$

  \vspace{1em}

  $\infrule{\infer{e}{\Sum{A}{B}} \quad \infer{f}{\Fun{A}{C}} \quad \infer{g}{\Fun{B}{C}}}{\infer{\case{e}{f}{g}}{C}}$

  \vspace{1em}

  $\infrule{\infer{a}{A} \quad \infer{b}{B}}{\infer{\pair{a}{b}}{\Prod{A}{B}}}$
\end{center}

\vspace{1em}

The basic rules are as presented in the previous slide. However, it is possible to add some enhancements. First, we can replace the rule for $\unit$ with an inference rule and if we need to check, we can use subsumption. Second, the paper argues that sum elimination is a general principle, and so it should allow both checking and inference versions. We could also add an inference rule for pairs. It seems there isn't a trade-off either -- if the checking rule fails, we can use subsumption and try to infer.

\end{frame}

\begin{frame}{(Non)uniqueness of typing}

Similarly to Extrinsic STLC, typing is not unique in Bidirectional STLC. This is because while we do have annotations in terms, we are not forced to use them. Therefore, we can check terms like $\fun{x}{x}$ with any type of the form $\Fun{A}{A}$. However, inference is unique.

\end{frame}

\section{Intrinsic}

\newcommand{\ifun}[3]{\lambda #1 : #2. #3}
\newcommand{\iinl}[2]{\texttt{inl}_{#1}\ #2}
\newcommand{\iinr}[2]{\texttt{inr}_{#1}\ #2}
\newcommand{\iexfalso}[2]{\texttt{exfalso}_{#1}\ #2}

\newcommand{\termdiff}[1]{\mathcolor{red}{#1}}

\begin{frame}{Intrinsic STLC}

Intrinsic STLC is the most widespread version of simply typed lambda calculus. The terms differ somewhat from Extrinsic STLC, as type annotations are mandatory on lambdas, sum constructors and the empty type eliminator, but the typing judgement remains the same.

\end{frame}

\begin{frame}{Terms}

Terms: \\
$e ::=$ \\
\qquad $x \pipe$ \\
\qquad $\termdiff{\ifun{x}{A}{e}} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl{e} \pipe \outr{e} \pipe$ \\
\qquad $\termdiff{\iinl{A}{e}} \pipe \termdiff{\iinr{A}{e}} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \termdiff{\iexfalso{A}{e}}$

\vspace{2em}

Note: red color marks places which differ from Extrinsic STLC.

\end{frame}

\begin{frame}{Declarative typing -- differences}

\begin{center}
  $\infrule{\fulltyping{\extend{\Gamma}{x}{A}}{e}{B}}{\typing{\ifun{x}{A}{e}}{\Fun{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{e}{A}}{\typing{\iinl{B}{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\typing{e}{B}}{\typing{\iinr{A}{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{e}{\Empty}}{\typing{\iexfalso{A}{e}}{A}}$
\end{center}

\vspace{2em}

Note: the only rules shown are those that differ from Extrinsic STLC.

\end{frame}

\begin{frame}{Type inference -- basics}

Thanks to abundant type annotations, we can (re)interpret the typing judgement $\fulltyping{\Gamma}{e}{A}$ as a type inference judgement $\fullinfer{\Gamma}{e}{A}$.

\vspace{2em}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma}}{\infer{x}{A}}$
\end{center}

\end{frame}

\begin{frame}{Type inference -- type-directed rules}

\begin{center}
  $\infrule{\fullinfer{\extend{\Gamma}{x}{A}}{e}{B}}{\infer{\ifun{x}{A}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\infer{f}{\Fun{A}{B}} \quad \infer{a}{A}}{\infer{\app{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\infer{a}{A} \quad \infer{b}{B}}{\infer{\pair{a}{b}}{\Prod{A}{B}}}$ \quad
  $\infrule{\infer{e}{\Prod{A}{B}}}{\infer{\outl{e}}{A}}$ \quad
  $\infrule{\infer{e}{\Prod{A}{B}}}{\infer{\outr{e}}{B}}$

  \vspace{2em}

  $\infrule{\infer{e}{A}}{\infer{\iinl{B}{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\infer{e}{B}}{\infer{\iinr{A}{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\infer{e}{\Sum{A}{B}} \quad \infer{f}{\Fun{A}{C}} \quad \infer{g}{\Fun{B}{C}}}{\infer{\case{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{}{\infer{\unit}{\Unit}}$ \quad
  $\infrule{\infer{e}{\Empty}}{\infer{\iexfalso{A}{e}}{A}}$
\end{center}

\end{frame}

\begin{frame}{Uniqueness of typing}

Because of the annotations on lambda, sum constructors and exfalso, Intrinsic STLC does enjoy uniqueness of typing. It is easy to prove this by induction: types of most terms are determined by the induction hypothesis, whereas for the aforementioned four we need to supplement the induction hypothesis with the annotation.

\end{frame}

\section{Dual Intrinsic}

\newcommand{\iapp}[3]{\texttt{app}_{#1}\ #2\ #3}
\newcommand{\ioutl}[2]{\texttt{outl}_{#1}\ #2}
\newcommand{\ioutr}[2]{\texttt{outr}_{#1}\ #2}
\newcommand{\icase}[5]{\texttt{case}_{#1, #2}\ #3\ \texttt{of}\ (#4, #5)}

\begin{frame}{Dual Intrinsic STLC}

If the usual Intrinsic STLC turns out to be a system in which we can infer all types, what would a system in which we can check all types look like?

\end{frame}

\begin{frame}{Terms}

Terms: \\
$e ::=$ \\
\qquad $x \pipe$ \\
\qquad $\fun{x}{e} \pipe \termdiff{\iapp{A}{e_1}{e_2}} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \termdiff{\ioutl{A}{e}} \pipe \termdiff{\ioutr{A}{e}} \pipe$ \\
\qquad $\inl{e} \pipe \inr{e} \pipe \termdiff{\icase{A}{B}{e}{e_1}{e_2}} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Note: red color marks places which differ from Extrinsic STLC.

\end{frame}

\begin{frame}{Declarative typing -- differences}

\begin{center}
  $\infrule{\typing{f}{\Fun{A}{B}} \quad \typing{a}{A}}{\typing{\iapp{A}{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\ioutl{B}{e}}{A}}$ \quad
  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\ioutr{A}{e}}{B}}$ \quad

  \vspace{2em}

  $\infrule{\typing{e}{\Sum{A}{B}} \quad \typing{f}{\Fun{A}{C}} \quad \typing{g}{\Fun{B}{C}}}{\typing{\icase{A}{B}{e}{f}{g}}{C}}$
\end{center}

\vspace{2em}

Note: the only rules shown are those that differ from Extrinsic STLC.

\end{frame}

\begin{frame}{Type checking -- basics}

Thanks to abundant type annotations, we can (re)interpret the typing judgement $\fulltyping{\Gamma}{e}{A}$ as a type checking judgement $\fullcheck{\Gamma}{e}{A}$.

\vspace{2em}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma}}{\check{x}{A}}$
\end{center}

\end{frame}

\begin{frame}{Type checking -- type-directed rules}

\begin{center}
  $\infrule{\fullcheck{\extend{\Gamma}{x}{A}}{e}{B}}{\check{\fun{x}{e}}{\Fun{A}{B}}}$ \enspace
  $\infrule{\check{f}{\Fun{A}{B}} \quad \check{a}{A}}{\check{\iapp{A}{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\check{a}{A} \quad \check{b}{B}}{\check{\pair{a}{b}}{\Prod{A}{B}}}$ \enspace
  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutl{B}{e}}{A}}$ \enspace
  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutr{A}{e}}{B}}$

  \vspace{2em}

  $\infrule{\check{e}{A}}{\check{\inl{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\check{e}{B}}{\check{\inr{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\check{e}{\Sum{A}{B}} \quad \check{f}{\Fun{A}{C}} \quad \check{g}{\Fun{B}{C}}}{\check{\icase{A}{B}{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{}{\check{\unit}{\Unit}}$ \quad
  $\infrule{\check{e}{\Empty}}{\check{\exfalso{e}}{A}}$
\end{center}

\end{frame}

\begin{frame}{(Non)uniqueness of typing}

Even though Dual Intrinsic STLC has plenty of mandatory annotations, it does not enjoy uniqueness of typing for the usual reasons: we can type $\fun{x}{x}$ with any type of the form $\Fun{A}{A}$. The role of the annotations is not to force types to be unique, but to make it possible to implement type checking.

\end{frame}

\section{Hinting}

\newcommand{\fullhinting}[4]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3 \mathcolor{red}{\Rightarrow} #4}
\newcommand{\hinting}[3]{\fullhinting{\Gamma}{#1}{#2}{#3}}

\newcommand{\Hole}{\textbf{?}}
\newcommand{\combinehints}[2]{#1 \sqcup #2}
\newcommand{\hintorder}[2]{#1 \sqsubseteq #2}
\newcommand{\hintfor}[1]{\texttt{hint}(#1)}

\begin{frame}{STLC with Hints}

STLC with Hints is a flavour of STLC inspired by Bidirectional STLC. The main insight behind it is that in Bidirectional STLC, we have a hard time deciding whether a rule should be in checking mode or in inference mode, so why not both? This way, we would have some input type that guides us, but also produce an output type, which is in some sense ``better''. This is a bit silly if we already have the correct type as input, but we can make this idea work by introducing hints, which are types with holes, and insisting that the input is not a type, but merely a hint.

\end{frame}

\begin{frame}{Hints}

$H ::= \Hole \pipe \Fun{H_1}{H_2} \pipe \Prod{H_1}{H_2} \pipe \Sum{H_1}{H_2} \pipe \Unit \pipe \Empty$

\vspace{2em}

Intuitively, hints are partial types. They are built like types, except that there's one additional constructor, $\Hole$, which can be read as ``hole'' or ``unknown''.

\vspace{2em}

We use the letter $H$ for hints. When we use letters like $A, B, C$ which usually stand in for types, it means that the hint \textbf{is} a type, i.e. it doesn't contain any $\Hole$s.

\end{frame}

\begin{frame}{Order on hints}

\begin{center}
  $\infrule{}{\hintorder{\Hole}{H}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Fun{H_1}{H_2}}{\Fun{H'_1}{H'_2}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Prod{H_1}{H_2}}{\Prod{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Sum{H_1}{H_2}}{\Sum{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{}{\hintorder{\Unit}{\Unit}}$ \quad
  $\infrule{}{\hintorder{\Empty}{\Empty}}$
\end{center}

\end{frame}

\begin{frame}{Order on hints -- intuition}

The order can be intuitively interpreted as information increase: $\hintorder{H_1}{H_2}$ means that hint $H_2$ is more informative than $H_1$, but in a compatible way. In other words, $H_1$ and $H_2$ have the same structure, but some $\Hole$s from $H_1$ were possibly refined to something more informative in $H_2$.

\end{frame}

\begin{frame}{Combining hints}

\begin{center}
  $\combinehints{\Hole}{H} = H$ \\
  $\combinehints{H}{\Hole} = H$ \\
  $\combinehints{(\Fun{H_1}{H_2})}{(\Fun{H'_1}{H'_2})} = \Fun{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Prod{H_1}{H_2})}{(\Prod{H'_1}{H'_2})} = \Prod{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Sum{H_1}{H_2})}{(\Sum{H'_1}{H'_2})} = \Sum{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{\Unit}{\Unit} = \Unit$ \\
  $\combinehints{\Empty}{\Empty} = \Empty$
\end{center}

The order on hints induces a partial operation $\combinehints{}{}$, which computes the least upper bound of two hints when it exists. Intuitively, $\combinehints{}{}$ combines two hints which share the same structure, filling the $\Hole$s in the leaves with something more informative coming from the other argument. For hints with incompatible structure the result is undefined.

\end{frame}

\begin{frame}{Combining hints -- properties}

If all relevant results are defined, then:

\begin{itemize}
  \item $\combinehints{(\combinehints{H_1}{H_2})}{H_3} = \combinehints{H_1}{(\combinehints{H_2}{H_3})}$
  \item $\combinehints{H_1}{H_2} = \combinehints{H_2}{H_1}$
  \item $\combinehints{\Hole}{H} = H = \combinehints{H}{\Hole}$
  \item $\combinehints{H}{H} = H$
\end{itemize}

\vspace{2em}

If $\combinehints{}{}$ were not partial, $(H, \combinehints{}{}, \Hole)$ would be a commutative idempotent monoid. But since it is partial, meh...

\end{frame}

\begin{frame}{Hints for term constructors}

\begin{center}
  $\hintfor{\fun{x}{e}} = \Fun{\Hole}{\Hole}$ \\
  $\hintfor{\pair{e_1}{e_2}} = \Prod{\Hole}{\Hole}$ \\
  $\hintfor{\inl{e}} = \Sum{\Hole}{\Hole}$ \\
  $\hintfor{\inr{e}} = \Sum{\Hole}{\Hole}$ \\
  $\hintfor{\unit} = \Unit$
\end{center}

\end{frame}

\begin{frame}{Terms}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \termdiff{\annot{e}{H}} \pipe $ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl{e} \pipe \outr{e} \pipe$ \\
\qquad $\inl{e} \pipe \inr{e} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Note: red color marks differences from Bidirectional STLC.

\vspace{2em}

Judgements: \\
$\fullhinting{\Gamma}{e}{H}{A}$ -- in context $\Gamma$, term $e$ checks with hint $H$ and infers type $A$

\end{frame}

\begin{frame}{Declarative typing -- differences}

\begin{center}
  $\infrule{\typing{e}{A} \quad \sidecond{\hintorder{H}{A}}}{\typing{\annot{e}{H}}{A}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- basic rules}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma} \quad \sidecond{\hintorder{H}{A}}}{\hinting{x}{H}{A}}$

  \vspace{2em}

  $\infrule[Annot]{\hinting{e}{\combinehints{H_1}{H_2}}{A}}{\hinting{\annot{e}{H_1}}{H_2}{A}}$

  \vspace{2em}

  $\infrule[Hole]{\hinting{e}{\hintfor{e}}{A} \quad \sidecond{e\ \texttt{constructor}}}{\hinting{e}{\Hole}{A}}$
\end{center}

\vspace{2em}

Note that the rule $\rulename{Hole}$ can only be applied once, because $\hintfor{e}$ can never be $\Hole$. After applying $\rulename{Hole}$, the only applicable rules are the type-directed ones.

\end{frame}

\begin{frame}{Hinting -- type-directed rules}

\begin{center}
  $\infrule{\fullhinting{\extend{\Gamma}{x}{A}}{e}{H}{B}}{\hinting{\fun{x}{e}}{\Fun{A}{H}}{\Fun{A}{B}}}$

  \vspace{1em}

  $\infrule{\hinting{f}{\Fun{\Hole}{H}}{\Fun{A}{B}} \quad \hinting{a}{A}{A}}{\hinting{\app{f}{a}}{H}{B}}$

  \vspace{1em}

  $\infrule{\hinting{a}{H_1}{A} \quad \hinting{b}{H_2}{B}}{\hinting{\pair{a}{b}}{\Prod{H_1}{H_2}}{\Prod{A}{B}}}$

  \vspace{1em}

  $\infrule{\hinting{e}{\Prod{H}{\Hole}}{\Prod{A}{B}}}{\hinting{\outl{e}}{H}{A}}$ \quad
  $\infrule{\hinting{e}{\Prod{H}{\Hole}}{\Prod{A}{B}}}{\hinting{\outr{e}}{H}{B}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- type-directed rules}

\begin{center}
  $\infrule{\hinting{e}{H}{A}}{\hinting{\inl{e}}{\Sum{H}{B}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{H}{B}}{\hinting{\inr{e}}{\Sum{A}{H}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{\Sum{\Hole}{\Hole}}{\Sum{A}{B}} \quad \begin{array}{c} \hinting{f}{\Fun{A}{H}}{\Fun{A}{C}} \\ \hinting{g}{\Fun{B}{C}}{\Fun{B}{C}} \end{array}}{\hinting{\case{e}{f}{g}}{H}{C}}$

  \vspace{2em}

  $\infrule{}{\hinting{\unit}{\Unit}{\Unit}}$ \quad
  $\infrule{\hinting{e}{\Empty}{\Empty}}{\hinting{\exfalso{e}}{A}{A}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- alternative rules}

\begin{center}
  $\infrule[AltApp]{\hinting{a}{?}{A} \quad \hinting{f}{\Fun{A}{H}}{\Fun{A}{B}}}{\hinting{\app{f}{a}}{H}{B}}$

  \vspace{2em}

  $\infrule[AltCase]{\begin{array}{c} \hinting{f}{\Fun{?}{H}}{\Fun{A}{C}} \\ \hinting{g}{\Fun{?}{C}}{\Fun{B}{C}} \end{array} \quad \hinting{e}{\Sum{A}{B}}{\Sum{A}{B}}}{\hinting{\case{e}{f}{g}}{H}{C}}$
\end{center}

\vspace{2em}

We could have made some different choices. For application, we could try to infer the argument type first and then feed it to the function as a hint. For case, we could try to infer domains of the branches first, then feed these as hints when checking the discriminee.

\end{frame}

\begin{frame}{Notations and derived terms}

We can introduce some handy notations:

\begin{itemize}
  \item $\check{e}{A} :\equiv \hinting{e}{A}{A}$
  \item $\infer{e}{A} :\equiv \hinting{e}{\Hole}{A}$
\end{itemize}

We can embed Intrinsic STLC terms:

\begin{itemize}
  \item $\ifun{x}{A}{e} :\equiv \annot{\fun{x}{e}}{\Fun{A}{\Hole}}$ \\
  \item $\iinl{B}{e} :\equiv \annot{\inl{e}}{\Sum{\Hole}{B}}$ \\
  \item $\iinr{A}{e} :\equiv \annot{\inr{e}}{\Sum{A}{\Hole}}$ \\
  \item $\iexfalso{A}{e} :\equiv \annot{\exfalso{e}}{A}$
\end{itemize}

We can also embed Dual Intrinsic STLC terms:

\begin{itemize}
  \item $\iapp{A}{f}{a} :\equiv \app{\annot{f}{\Fun{A}{\Hole}}}{a}$
  \item $\ioutl{B}{e} :\equiv \outl{\annot{e}{\Prod{\Hole}{B}}}$
  \item $\ioutr{A}{e} :\equiv \outr{\annot{e}{\Prod{A}{\Hole}}}$
  \item $\icase{A}{B}{e}{f}{g} :\equiv \case{\annot{e}{\Sum{A}{B}}}{f}{g}$
\end{itemize}

\end{frame}

\begin{frame}{Rules for derived terms}

\begin{center}
  $\infrule{\fullinfer{\extend{\Gamma}{x}{A}}{e}{B}}{\infer{\ifun{x}{A}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\check{f}{\Fun{A}{B}} \quad \check{a}{A}}{\check{\iapp{A}{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutl{B}{e}}{A}}$ \enspace
  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutr{A}{e}}{B}}$

  \vspace{2em}

  $\infrule{\infer{e}{A}}{\infer{\iinl{B}{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\infer{e}{B}}{\infer{\iinr{A}{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\check{e}{\Sum{A}{B}} \quad \check{f}{\Fun{A}{C}} \quad \check{g}{\Fun{B}{C}}}{\check{\icase{A}{B}{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{\infer{e}{\Empty}}{\infer{\iexfalso{A}{e}}{A}}$
\end{center}

\end{frame}

\begin{frame}{(Non)uniqueness of typing}

Similarly to Extrinsic STLC, STLC with Hints does not enjoy uniqueness of typing. This is because we still can have terms like $\fun{x}{x}$ with hint $\Hole$, which can be typed with any type of the form $\Fun{A}{A}$. However, if the hint is informative enough, then the type is unique. Moreover, every typable term can be given a hint which makes its type unique.

\end{frame}

\section{Output contexts}

\newcommand{\fulloutctx}[5]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3 \mathcolor{red}{\Rightarrow} #4 \dashv #5}
\newcommand{\outctx}[3]{\fulloutctx{\Gamma}{#1}{#2}{#3}{\Gamma'}}
\newcommand{\shortoutctx}[3]{#1 \mathcolor{blue}{\Leftarrow} #2 \mathcolor{red}{\Rightarrow} #3}

\begin{frame}{Terms and judgements}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \annot{e}{H} \pipe $ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl{e} \pipe \outr{e} \pipe$ \\
\qquad $\inl{e} \pipe \inr{e} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Note: the terms are the same as in STLC with Hints.

\vspace{2em}

Judgements: \\
$\fulloutctx{\Gamma}{e}{H}{H'}{\Gamma'}$ -- in context $\Gamma$, term $e$ checks with hint $H$ and infers hint $H'$ in output context $\Gamma'$

\end{frame}

\begin{frame}{Output contexts -- basic rules}

\begin{center}
  $\infrule[Var]{}{\fulloutctx{\Gamma_1, x : A, \Gamma_2}{x}{B}{\combinehints{A}{B}}{\Gamma_1, x : \combinehints{A}{B}, \Gamma_2}}$

  \vspace{2em}

  $\infrule[Annot]{\outctx{e}{\combinehints{A}{B}}{C}}{\outctx{\annot{e}{A}}{B}{C}}$

  \vspace{2em}

  $\infrule[Hole]{\outctx{e}{\hintfor{e}}{A} \quad \sidecond{e\ \texttt{constructor}}}{\outctx{e}{\Hole}{A}}$
\end{center}

\vspace{2em}

Note that the rule $\rulename{Hole}$ can only be applied once, because $\hintfor{e}$ can never be $\Hole$. After applying $\rulename{Hole}$, the only applicable rules are the type-directed ones.

\end{frame}

\begin{frame}{Output contexts -- type-directed rules}

\begin{center}
  $\infrule{\fulloutctx{\extend{\Gamma}{x}{A}}{e}{B}{B'}{\extend{\Gamma'}{x}{A'}}}{\outctx{\fun{x}{e}}{\Fun{A}{B}}{\Fun{A'}{B'}}}$

  \vspace{1em}

  $\infrule{\fulloutctx{\Gamma}{f}{\Fun{\Hole}{B}}{\Fun{A}{B'}}{\Gamma'} \quad \fulloutctx{\Gamma'}{a}{A}{A'}{\Gamma''}}{\fulloutctx{\Gamma}{\app{f}{a}}{B}{B'}{\Gamma''}}$

  \vspace{1em}

  $\infrule{\fulloutctx{\Gamma}{a}{A}{A'}{\Gamma'} \quad \fulloutctx{\Gamma'}{b}{B}{B'}{\Gamma''}}{\fulloutctx{\Gamma}{\pair{a}{b}}{\Prod{A}{B}}{\Prod{A'}{B'}}{\Gamma''}}$

  \vspace{1em}

  $\infrule{\outctx{e}{\Prod{A}{\Hole}}{\Prod{A'}{B}}}{\outctx{\outl{e}}{A}{A'}}$
  \quad
  $\infrule{\outctx{e}{\Prod{\Hole}{B}}{\Prod{A}{B'}}}{\outctx{\outr{e}}{B}{B'}}$
\end{center}

\end{frame}

\begin{frame}{Output contexts -- type-directed rules}

\begin{center}
  $\infrule{\outctx{e}{A}{A'}}{\outctx{\inl{e}}{\Sum{A}{B}}{\Sum{A'}{B}}}$

  \vspace{2em}

  $\infrule{\outctx{e}{B}{B'}}{\outctx{\inr{e}}{\Sum{A}{B}}{\Sum{A}{B'}}}$

  \vspace{2em}

  $\infrule{\fulloutctx{\Gamma}{e}{\Sum{\Hole}{\Hole}}{\Sum{A}{B}}{\Gamma_1} \quad \begin{array}{c} \fulloutctx{\Gamma_1}{f}{\Fun{A}{C_1}}{\Fun{A'}{C_2}}{\Gamma_2} \\ \fulloutctx{\Gamma_2}{g}{\Fun{B}{C_2}}{\Fun{B'}{C_3}}{\Gamma_3} \end{array}}{\fulloutctx{\Gamma}{\case{e}{f}{g}}{C_1}{C_3}{\Gamma_3}}$

  \vspace{2em}

  $\infrule{}{\outctx{\unit}{\Unit}{\Unit}}$
  \quad
  $\infrule{\outctx{e}{\Empty}{\Empty}}{\outctx{\exfalso{e}}{A}{A}}$
\end{center}

\end{frame}

\begin{frame}{Output contexts -- abridged basic rules}

\begin{center}
  $\infrule[Var]{}{\fulloutctx{\Gamma_1, x : A, \Gamma_2}{x}{B}{\combinehints{A}{B}}{\Gamma_1, x : \combinehints{A}{B}, \Gamma_2}}$

  \vspace{2em}

  $\infrule[Annot]{\shortoutctx{e}{\combinehints{A}{B}}{C}}{\shortoutctx{\annot{e}{A}}{B}{C}}$

  \vspace{2em}

  $\infrule[Hole]{\shortoutctx{e}{\hintfor{e}}{A} \quad \sidecond{e\ \texttt{constructor}}}{\shortoutctx{e}{\Hole}{A}}$
\end{center}

\vspace{2em}

Note that the rule $\rulename{Hole}$ can only be applied once, because $\hintfor{e}$ can never be $\Hole$. After applying $\rulename{Hole}$, the only applicable rules are the type-directed ones.

\end{frame}

\begin{frame}{Output contexts -- abridged type-directed rules}

\begin{center}
  $\infrule{\fulloutctx{\extend{\Gamma}{x}{A}}{e}{B}{B'}{\extend{\Gamma'}{x}{A'}}}{\outctx{\fun{x}{e}}{\Fun{A}{B}}{\Fun{A'}{B'}}}$

  \vspace{1em}

  $\infrule{\fulloutctx{\Gamma}{f}{\Fun{\Hole}{B}}{\Fun{A}{B'}}{\Gamma'} \quad \fulloutctx{\Gamma'}{a}{A}{A'}{\Gamma''}}{\fulloutctx{\Gamma}{\app{f}{a}}{B}{B'}{\Gamma''}}$

  \vspace{1em}

  $\infrule{\fulloutctx{\Gamma}{a}{A}{A'}{\Gamma'} \quad \fulloutctx{\Gamma'}{b}{B}{B'}{\Gamma''}}{\fulloutctx{\Gamma}{\pair{a}{b}}{\Prod{A}{B}}{\Prod{A'}{B'}}{\Gamma''}}$

  \vspace{1em}

  $\infrule{\shortoutctx{e}{\Prod{A}{\Hole}}{\Prod{A'}{B}}}{\shortoutctx{\outl{e}}{A}{A'}}$
  \quad
  $\infrule{\shortoutctx{e}{\Prod{\Hole}{B}}{\Prod{A}{B'}}}{\shortoutctx{\outr{e}}{B}{B'}}$
\end{center}

\end{frame}

\begin{frame}{Output contexts -- abridged type-directed rules}

\begin{center}
  $\infrule{\shortoutctx{e}{A}{A'}}{\shortoutctx{\inl{e}}{\Sum{A}{B}}{\Sum{A'}{B}}}$

  \vspace{2em}

  $\infrule{\shortoutctx{e}{B}{B'}}{\shortoutctx{\inr{e}}{\Sum{A}{B}}{\Sum{A}{B'}}}$

  \vspace{2em}

  $\infrule{\fulloutctx{\Gamma}{e}{\Sum{\Hole}{\Hole}}{\Sum{A}{B}}{\Gamma_1} \quad \begin{array}{c} \fulloutctx{\Gamma_1}{f}{\Fun{A}{C_1}}{\Fun{A'}{C_2}}{\Gamma_2} \\ \fulloutctx{\Gamma_2}{g}{\Fun{B}{C_2}}{\Fun{B'}{C_3}}{\Gamma_3} \end{array}}{\fulloutctx{\Gamma}{\case{e}{f}{g}}{C_1}{C_3}{\Gamma_3}}$

  \vspace{2em}

  $\infrule{}{\shortoutctx{\unit}{\Unit}{\Unit}}$
  \quad
  $\infrule{\shortoutctx{e}{\Empty}{\Empty}}{\shortoutctx{\exfalso{e}}{A}{A}}$
\end{center}

\end{frame}

\end{document}