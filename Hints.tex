\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
  colorlinks = true,
  linkcolor = blue,
  urlcolor  = blue,
  citecolor = blue,
  anchorcolor = blue
}
\usepackage{Commands}

\usetheme{Darmstadt}

\title{Hinting\\A nice presentation of algorithmic typing}
\author{Wojciech Ko≈Çowski}
\date{}

\begin{document}

\frame{\titlepage}

\section{Intro}

\begin{frame}{STLC with Hints}

STLC with Hints is a flavour of STLC inspired by Bidirectional STLC. The main insight behind it is that in Bidirectional STLC, we have a hard time deciding whether a rule should be in checking mode or in inference mode, so why not both? This way, we would have some input type that guides us, but also produce an output type, which is in some sense ``better''. This is a bit silly if we already have the correct type as input, but we can make this idea work by introducing hints, which are types with holes, and insisting that the input is not a type, but merely a hint.

\end{frame}

\section{Hints}

\begin{frame}{Hints}

$H ::= \Hole \pipe \Fun{H_1}{H_2} \pipe \Prod{H_1}{H_2} \pipe \Sum{H_1}{H_2} \pipe \Unit \pipe \Empty$

\vspace{2em}

Intuitively, hints are partial types. They are built like types, except that there's one additional constructor, $\Hole$, which can be read as ``hole'' or ``unknown''.

\vspace{2em}

We use the letter $H$ for hints. When we use letters like $A, B, C$ which usually stand in for types, it means that the hint \textbf{is} a type, i.e. it doesn't contain any $\Hole$s.

\end{frame}

\begin{frame}{Order on hints}

\begin{center}
  $\infrule{}{\hintorder{\Hole}{H}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Fun{H_1}{H_2}}{\Fun{H'_1}{H'_2}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Prod{H_1}{H_2}}{\Prod{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Sum{H_1}{H_2}}{\Sum{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{}{\hintorder{\Unit}{\Unit}}$ \quad
  $\infrule{}{\hintorder{\Empty}{\Empty}}$
\end{center}

\end{frame}

\begin{frame}{Order on hints -- intuition}

The order can be intuitively interpreted as information increase: $\hintorder{H_1}{H_2}$ means that hint $H_2$ is more informative than $H_1$, but in a compatible way. In other words, $H_1$ and $H_2$ have the same structure, but some $\Hole$s from $H_1$ were possibly refined to something more informative in $H_2$.

\end{frame}

\begin{frame}{Combining hints}

\begin{center}
  $\combinehints{\Hole}{H} = H$ \\
  $\combinehints{H}{\Hole} = H$ \\
  $\combinehints{(\Fun{H_1}{H_2})}{(\Fun{H'_1}{H'_2})} = \Fun{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Prod{H_1}{H_2})}{(\Prod{H'_1}{H'_2})} = \Prod{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Sum{H_1}{H_2})}{(\Sum{H'_1}{H'_2})} = \Sum{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{\Unit}{\Unit} = \Unit$ \\
  $\combinehints{\Empty}{\Empty} = \Empty$
\end{center}

The order on hints induces a partial operation $\combinehints{}{}$, which computes the least upper bound of two hints when it exists. Intuitively, $\combinehints{}{}$ combines two hints which share the same structure, filling the $\Hole$s in the leaves with something more informative coming from the other argument. For hints with incompatible structure the result is undefined.

\end{frame}

\begin{frame}{Combining hints -- properties}

If all relevant results are defined, then:

\begin{itemize}
  \item $\combinehints{(\combinehints{H_1}{H_2})}{H_3} = \combinehints{H_1}{(\combinehints{H_2}{H_3})}$
  \item $\combinehints{H_1}{H_2} = \combinehints{H_2}{H_1}$
  \item $\combinehints{\Hole}{H} = H = \combinehints{H}{\Hole}$
  \item $\combinehints{H}{H} = H$
\end{itemize}

\vspace{2em}

If $\combinehints{}{}$ were not partial, $(H, \combinehints{}{}, \Hole)$ would be a commutative idempotent monoid. But since it is partial, meh...

\end{frame}

\begin{frame}{Hints for term constructors}

\begin{center}
  $\hintfor{\fun{x}{e}} = \Fun{\Hole}{\Hole}$ \\
  $\hintfor{\pair{e_1}{e_2}} = \Prod{\Hole}{\Hole}$ \\
  $\hintfor{\inl{e}} = \Sum{\Hole}{\Hole}$ \\
  $\hintfor{\inr{e}} = \Sum{\Hole}{\Hole}$ \\
  $\hintfor{\unit} = \Unit$
\end{center}

\end{frame}

\section{Declarative typing}

\begin{frame}{Terms}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \termdiff{\annot{e}{H}} \pipe $ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl{e} \pipe \outr{e} \pipe$ \\
\qquad $\inl{e} \pipe \inr{e} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Note: red color marks differences from Bidirectional STLC.

\vspace{2em}

Judgements: \\
$\fullhinting{\Gamma}{e}{H}{A}$ -- in context $\Gamma$, term $e$ checks with hint $H$ and infers type $A$

\end{frame}

\begin{frame}{Declarative typing -- differences}

\begin{center}
  $\infrule[Annot]{\typing{e}{A} \quad \sidecond{\hintorder{H}{A}}}{\typing{\annot{e}{H}}{A}}$
\end{center}

\end{frame}

\section{Algorithmic typing}

\begin{frame}{Algorithmic typing -- basic rules}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma} \quad \sidecond{\hintorder{H}{A}}}{\hinting{x}{H}{A}}$

  \vspace{2em}

  $\infrule[Annot]{\hinting{e}{\combinehints{H_1}{H_2}}{A}}{\hinting{\annot{e}{H_1}}{H_2}{A}}$

  \vspace{2em}

  $\infrule[Hole]{\hinting{e}{\hintfor{e}}{A} \quad \sidecond{e\ \texttt{constructor}}}{\hinting{e}{\Hole}{A}}$
\end{center}

\vspace{2em}

Note that the rule $\rulename{Hole}$ can only be applied once, because $\hintfor{e}$ can never be $\Hole$. After applying $\rulename{Hole}$, the only applicable rules are the type-directed ones.

\end{frame}

\begin{frame}{Algorithmic typing -- type-directed rules}

\begin{center}
  $\infrule{\fullhinting{\extend{\Gamma}{x}{A}}{e}{H}{B}}{\hinting{\fun{x}{e}}{\Fun{A}{H}}{\Fun{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{f}{\Fun{\Hole}{H}}{\Fun{A}{B}} \quad \hinting{a}{A}{A}}{\hinting{\app{f}{a}}{H}{B}}$

  \vspace{2em}

  $\infrule{\hinting{a}{H_A}{A} \quad \hinting{b}{H_B}{B}}{\hinting{\pair{a}{b}}{\Prod{H_A}{H_B}}{\Prod{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{\Prod{H}{\Hole}}{\Prod{A}{B}}}{\hinting{\outl{e}}{H}{A}}$ \quad
  $\infrule{\hinting{e}{\Prod{\Hole}{H}}{\Prod{A}{B}}}{\hinting{\outr{e}}{H}{B}}$
\end{center}

\end{frame}

\begin{frame}{Algorithmic typing -- type-directed rules}

\begin{center}
  $\infrule{\hinting{e}{H}{A}}{\hinting{\inl{e}}{\Sum{H}{B}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{H}{B}}{\hinting{\inr{e}}{\Sum{A}{H}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{\Sum{\Hole}{\Hole}}{\Sum{A}{B}} \quad \begin{array}{c} \hinting{f}{\Fun{A}{H}}{\Fun{A}{C}} \\ \hinting{g}{\Fun{B}{C}}{\Fun{B}{C}} \end{array}}{\hinting{\case{e}{f}{g}}{H}{C}}$

  \vspace{2em}

  $\infrule{}{\hinting{\unit}{\Unit}{\Unit}}$ \quad
  $\infrule{\hinting{e}{\Empty}{\Empty}}{\hinting{\exfalso{e}}{A}{A}}$
\end{center}

\end{frame}

\begin{frame}{Algorithmic typing -- alternative rules}

\begin{center}
  $\infrule[AltApp]{\hinting{a}{\Hole}{A} \quad \hinting{f}{\Fun{A}{H}}{\Fun{A}{B}}}{\hinting{\app{f}{a}}{H}{B}}$

  \vspace{2em}

  $\infrule[AltCase]{\begin{array}{c} \hinting{f}{\Fun{\Hole}{H}}{\Fun{A}{C}} \\ \hinting{g}{\Fun{\Hole}{C}}{\Fun{B}{C}} \end{array} \quad \hinting{e}{\Sum{A}{B}}{\Sum{A}{B}}}{\hinting{\case{e}{f}{g}}{H}{C}}$
\end{center}

\vspace{2em}

We could have made some different choices. For application, we could try to infer the argument type first and then feed it to the function as a hint. For case, we could try to infer domains of the branches first, then feed these as hints when checking the discriminee.

\end{frame}

\section{Metatheory}

\begin{frame}{Metatheory -- basics}

If $\fullhinting{\Gamma}{e}{H}{A}$ then:

\begin{itemize}
  \item (Soundness) $\fulltyping{\Gamma}{e}{A}$ (proof: induction)
  \item (Compatibility) $\hintorder{H}{A}$ (proof: induction)
  \item (Squeeze) If $\hintorder{H}{H'}$ and $\hintorder{H'}{A}$, then $\fullhinting{\Gamma}{e}{H'}{A}$ (proof: induction)
  \item (Upper bound) If $\fullhinting{\Gamma}{e}{H'}{A}$, then $\fullhinting{\Gamma}{e}{\combinehints{H}{H'}}{A}$ (proof: follows from the above)
  \item (Decidability) For $\Gamma, e, H$ it is decidable whether there exists $A$ such that $\fullhinting{\Gamma}{e}{H}{A}$ (proof: the rules are literally the algorithm)
\end{itemize}

\end{frame}

\newcommand{\subtracthints}[2]{#1 \setminus #2}

\begin{frame}{Hint subtraction}

\begin{center}
  $\subtracthints{\Hole}{H} = \Hole$ \\
  $\subtracthints{H}{\Hole} = H$ \\
  $\subtracthints{H}{H} = \Hole$ \\
  $\subtracthints{(\Fun{H_1}{H_2})}{(\Fun{H'_1}{H'_2})} = \Fun{(\subtracthints{H_1}{H'_1})}{(\subtracthints{H_2}{H'_2})}$ \\
  $\subtracthints{(\Prod{H_1}{H_2})}{(\Prod{H'_1}{H'_2})} = \Prod{(\subtracthints{H_1}{H'_1})}{(\subtracthints{H_2}{H'_2})}$ \\
  $\subtracthints{(\Sum{H_1}{H_2})}{(\Sum{H'_1}{H'_2})} = \Sum{(\subtracthints{H_1}{H'_1})}{(\subtracthints{H_2}{H'_2})}$
\end{center}

\vspace{2em}

Hint subtraction is a partial operation which we'll need when proving minimality. When subtracting a hint from itself or from $\Hole$, the result is $\Hole$, and subtracting $\Hole$ changes nothing. In the remaining cases, when the hints are not equal but have the same structure, the subtraction proceeds recursively.

\end{frame}

\begin{frame}{Hint subtraction -- properties}

\begin{itemize}
  \item If $\hintorder{H_1}{H_2}$, then $\hintorder{\subtracthints{H_1}{H}}{\subtracthints{H_2}{H}}$
\end{itemize}

\end{frame}

\begin{frame}{Metatheory -- minimality}

(Minimality) There exists $\hintorder{H'}{H}$ such that $\fullhinting{\Gamma}{e}{H'}{A}$ and for all $\stricthintorder{H''}{H'}$ it is not the case that $\fullhinting{\Gamma}{e}{H''}{A}$ (proof: induction, the only hard case is $\rulename{Annot}$)

\vspace{1em}

Proof: we need $\hinting{\annot{e}{H_1}}{H'}{A}$ for minimal $H'$. From the induction hypothesis we have minimal $\hintorder{H'}{\combinehints{H_1}{H_2}}$ such that $\hinting{e}{H'}{A}$. Our minimal hint will be $\subtracthints{H'}{H_1}$, so we need $\hinting{\annot{e}{H_1}}{\subtracthints{H'}{H_1}}{A}$. Since $\combinehints{H_1}{(\subtracthints{H'}{H_1})} = \combinehints{H_1}{H'}$, it suffices to show $\hinting{e}{\combinehints{H_1}{H'}}{A}$, which follows from squeezing and IH, because $\triplehintorder{H'}{\combinehints{H_1}{H'}}{\combinehints{H_1}{H_2}}$. Of course we also have $\triplehintorder{\subtracthints{H'}{H_1}}{\subtracthints{H_2}{H_1}}{H_2}$.

\end{frame}

\begin{frame}{Metatheory -- minimality, cont.}

Now assume $\stricthintorder{H''}{\subtracthints{H'}{H_1}}$ and $\hinting{\annot{e}{H_1}}{H''}{A}$. We have $\stricthintorder{H''}{H'}$ and so $\stricthintorder{H''}{H_2}$.

\end{frame}

\begin{frame}{Metatheory -- minimality v2}

\end{frame}

\begin{frame}{Information order on terms}

The order on hints induces an order on terms: it is the smallest relation which preserves term constructors and subsumes hint ordering on annotated terms.

\vspace{2em}

\begin{center}
  $\infrule{\termorder{e_1}{e_2} \quad \hintorder{H_1}{H_2}}{\termorder{\annot{e_1}{H_1}}{\annot{e_2}{H_2}}}$
\end{center}

\vspace{2em}

Intuitively, $\termorder{e_1}{e_2}$ holds when $e_2$ has more informative hints than $e_1$.

\end{frame}

\begin{frame}{Information order on terms -- rules}

\begin{center}
  $\infrule{}{\termorder{x}{x}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\fun{x}{e_1}}{\fun{x}{e_2}}}$ \quad
  $\infrule{\termorder{f_1}{f_2} \quad \termorder{a_1}{a_2}}{\termorder{\app{f_1}{a_1}}{\app{f_2}{a_2}}}$

  \vspace{2em}

  $\infrule{\termorder{a_1}{a_2} \quad \termorder{b_1}{b_2}}{\termorder{\pair{a_1}{b_1}}{\pair{a_2}{b_2}}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\outl{e_1}}{\outl{e_2}}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\outl{e_1}}{\outr{e_2}}}$

  \vspace{2em}

  $\infrule{\termorder{e_1}{e_2}}{\termorder{\inl{e_1}}{\inl{e_2}}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\inr{e_1}}{\inr{e_2}}}$

  \vspace{2em}

  $\infrule{\termorder{e_1}{e_2} \quad \termorder{f_1}{f_2} \quad \termorder{g_1}{g_2}}{\termorder{\case{e_1}{f_1}{g_1}}{\case{e_2}{f_2}{g_2}}}$

  \vspace{2em}

  $\infrule{}{\termorder{\unit}{\unit}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\exfalso{e_1}}{\exfalso{e_2}}}$
\end{center}

\end{frame}

\begin{frame}{Metatheory 2}

If $\fulltyping{\Gamma}{e}{A}$, then:

\begin{itemize}
  \item (Annotability) There exists $e'$ such that $\termorder{e}{e'}$ and $\fullhinting{\Gamma}{e'}{A}{A}$
  \item (Minimal annotability) There exists $e'$ such that $\termorder{e}{e'}$ and $\fullhinting{\Gamma}{e'}{A}{A}$ and for all $e''$ such that $\termorder{e}{e''}$ and $\termorder{e''}{e'}$ it is not the case that $\fullhinting{\Gamma}{e''}{A}{A}$
  \item There exist $\termorder{e}{e_1}$ and $\hintorder{H_1}{A}$ such that $\fullhinting{\Gamma}{e_1}{H_1}{A}$ and for all $\tripletermorder{e}{e_2}{e_1}$ and $\triplehintorder{H}{H'}{A}$ it is not the case that $\fullhinting{\Gamma}{e_2}{H_2}{A}$
\end{itemize}

\end{frame}

\begin{frame}{(Non)uniqueness of typing}

Similarly to Extrinsic STLC, STLC with Hints does not enjoy uniqueness of typing. This is because we still can have terms like $\fun{x}{x}$ with hint $\Hole$, which can be typed with any type of the form $\Fun{A}{A}$. However, if the hint is informative enough, then the type is unique. Moreover, every typable term can be given a hint which makes its type unique.

\end{frame}

\section{Embedding}

\begin{frame}{Checking and inference mode}

With our hint-based approach, checking and inference modes, familiar from Bidirectional STLC, are easily definable:

\begin{itemize}
  \item $\check{e}{A}$ is defined as $\hinting{e}{A}{A}$
  \item $\infer{e}{A}$ is defined as $\hinting{e}{\Hole}{A}$
\end{itemize}

\end{frame}

\begin{frame}{Embedding Bidirectional STLC}

\end{frame}

\begin{frame}{Embedding Intrinsic STLC}

We can embed Intrinsic STLC terms:

\begin{itemize}
  \item $\ifun{x}{A}{e} :\equiv \annot{\fun{x}{e}}{\Fun{A}{\Hole}}$ \\
  \item $\iinl{B}{e} :\equiv \annot{\inl{e}}{\Sum{\Hole}{B}}$ \\
  \item $\iinr{A}{e} :\equiv \annot{\inr{e}}{\Sum{A}{\Hole}}$ \\
  \item $\iexfalso{A}{e} :\equiv \annot{\exfalso{e}}{A}$
\end{itemize}

\end{frame}

\begin{frame}{Embedding Dual Intrinsic STLC}

We can also embed Dual Intrinsic STLC terms:

\begin{itemize}
  \item $\iapp{A}{f}{a} :\equiv \app{\annot{f}{\Fun{A}{\Hole}}}{a}$
  \item $\ioutl{B}{e} :\equiv \outl{\annot{e}{\Prod{\Hole}{B}}}$
  \item $\ioutr{A}{e} :\equiv \outr{\annot{e}{\Prod{A}{\Hole}}}$
  \item $\icase{A}{B}{e}{f}{g} :\equiv \case{\annot{e}{\Sum{A}{B}}}{f}{g}$
\end{itemize}

\end{frame}

\begin{frame}{Rules for derived terms}

\begin{center}
  $\infrule{\fullinfer{\extend{\Gamma}{x}{A}}{e}{B}}{\infer{\ifun{x}{A}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\check{f}{\Fun{A}{B}} \quad \check{a}{A}}{\check{\iapp{A}{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutl{B}{e}}{A}}$ \enspace
  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutr{A}{e}}{B}}$

  \vspace{2em}

  $\infrule{\infer{e}{A}}{\infer{\iinl{B}{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\infer{e}{B}}{\infer{\iinr{A}{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\check{e}{\Sum{A}{B}} \quad \check{f}{\Fun{A}{C}} \quad \check{g}{\Fun{B}{C}}}{\check{\icase{A}{B}{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{\infer{e}{\Empty}}{\infer{\iexfalso{A}{e}}{A}}$
\end{center}

\end{frame}

\end{document}