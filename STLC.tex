\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{xcolor}
\usetheme{Darmstadt}

\newcommand{\pipe}{\ |\ }

\newcommand{\Fun}[2]{#1 \to #2}
\newcommand{\Prod}[2]{#1 \times #2}
\newcommand{\Sum}[2]{#1 + #2}
\newcommand{\Unit}{\textbf{1}}
\newcommand{\Empty}{\textbf{0}}

\newcommand{\annot}[2]{(#1 : #2)}
\newcommand{\fun}[2]{\lambda #1. #2}
\newcommand{\app}[2]{#1\ #2}
\newcommand{\pair}[2]{(#1, #2)}
\newcommand{\outl}[1][]{\texttt{outl}\ #1}
\newcommand{\outr}[1][]{\texttt{outr}\ #1}
\newcommand{\inl}[1][]{\texttt{inl}\ #1}
\newcommand{\inr}[1][]{\texttt{inr}\ #1}
\newcommand{\case}[3]{\texttt{case}\ #1\ \texttt{of}\ (#2, #3)}
\newcommand{\unit}{\texttt{unit}}
\newcommand{\exfalso}[1][]{\texttt{exfalso}\ #1}

\newcommand{\subst}[3]{#1\left[#2 := #3\right]}

\newcommand{\tyctx}[1]{\mathcolor{brown}{#1\ \texttt{ctx}}}

\newcommand{\fulltyping}[3]{#1 \vdash #2 : #3}
\newcommand{\typing}[2]{\fulltyping{\Gamma}{#1}{#2}}

\newcommand{\infrule}[3][]{\displaystyle \frac{#2}{#3} \textsc{\footnotesize{#1}}}

\newcommand{\emptytypingctx}{\cdot}
\newcommand{\extend}[3]{#1, #2 : #3}
\newcommand{\extenddef}[4]{#1, #2 : #3 := #4}

\newcommand{\sidecond}[1]{#1}

\title{STLC}

\begin{document}

\section{Common parts}

\begin{frame}{Types, contexts and terms}

Types: \\
$A, B ::= \Fun{A}{B} \pipe \Prod{A}{B} \pipe \Sum{A}{B} \pipe \Unit \pipe \Empty$

\vspace{2em}

Typing contexts: \\
$\Gamma ::= \emptytypingctx \pipe \extend{\Gamma}{x}{A}$

\end{frame}

\section{Extrinsic STLC}

\begin{frame}{Terms}

Terms: \\
$e ::=$ \\
\qquad $x \pipe$ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl[e] \pipe \outr[e] \pipe$ \\
\qquad $\inl[e] \pipe \inr[e] \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\end{frame}

\begin{frame}{Declarative typing -- basics}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma}}{\typing{x}{A}}$
\end{center}

\end{frame}

\begin{frame}{Declarative typing -- type-directed rules}

\begin{center}
  $\infrule{\fulltyping{\extend{\Gamma}{x}{A}}{e}{B}}{\typing{\fun{x}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\typing{f}{\Fun{A}{B}} \quad \typing{a}{A}}{\typing{\app{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\typing{a}{A} \quad \typing{b}{B}}{\typing{\pair{a}{b}}{\Prod{A}{B}}}$ \quad
  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\outl[e]}{A}}$ \quad
  $\infrule{\typing{e}{\Prod{A}{B}}}{\typing{\outr[e]}{B}}$

  \vspace{2em}

  $\infrule{\typing{e}{A}}{\typing{\inl[e]}{\Sum{A}{B}}}$ \quad
  $\infrule{\typing{e}{B}}{\typing{\inr[e]}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{e}{\Sum{A}{B}} \quad \typing{f}{\Fun{A}{C}} \quad \typing{g}{\Fun{B}{C}}}{\typing{\case{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{}{\typing{\unit}{\Unit}}$ \quad
  $\infrule{\typing{e}{\Empty}}{\typing{\exfalso[e]}{A}}$
\end{center}

\end{frame}

\begin{frame}{Metatheory}

Extrinsic STLC enjoys strong metatheoretical properties:

\begin{itemize}
  \item Termination: computation on well-typed terms always terminates.
  \item Confluence: computing with a well-typed term produces a unique result.
  \item Type preservation: computing with a well-typed term preserves its type.
  \item Canonicity: in the empty context, normal forms are inductively generated from term constructors.
\end{itemize}

However, extrinsic STLC does not enjoy another important property: \textbf{uniqueness of typing}. This means that there are terms which can be assigned multiple types.

\end{frame}

\section{Intrinsic STLC}

\newcommand{\ifun}[3]{\lambda #1 : #2. #3}
\newcommand{\iinl}[2]{\texttt{inl}_{#1}\ #2}
\newcommand{\iinr}[2]{\texttt{inr}_{#1}\ #2}
\newcommand{\iexfalso}[2]{\texttt{exfalso}_{#1}\ #2}

\newcommand{\termdiff}[1]{\mathcolor{red}{#1}}

\begin{frame}{Terms}

Note: red color marks places which differ from Extrinsic STLC.

\vspace{2em}

Terms: \\
$e ::=$ \\
\qquad $x \pipe$ \\
\qquad $\termdiff{\ifun{x}{A}{e}} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl[e] \pipe \outr[e] \pipe$ \\
\qquad $\termdiff{\iinl{A}{e}} \pipe \termdiff{\iinr{A}{e}} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \termdiff{\iexfalso{A}{e}}$

\vspace{2em}

\end{frame}

\begin{frame}{Declarative typing -- differences}

\begin{center}
  $\infrule{\fulltyping{\extend{\Gamma}{x}{A}}{e}{B}}{\typing{\ifun{x}{A}{e}}{\Fun{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{e}{A}}{\typing{\iinl{B}{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\typing{e}{B}}{\typing{\iinr{A}{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\typing{e}{\Empty}}{\typing{\iexfalso{A}{e}}{A}}$
\end{center}

\end{frame}

\begin{frame}{Metatheory}

Because of the annotations on lambda, sum constructors and exfalso, intrinsic STLC does enjoy uniqueness of typing. It is easy to prove this by induction: types of most terms are determined by the induction hypothesis, whereas for the aforementioned four we need to supplement the induction hypothesis with the annotation.

\end{frame}

\section{Bidirectional STLC}

\newcommand{\newterm}[1]{\mathcolor{green}{#1}}

\begin{frame}{Terms}

Note: green color marks terms which were not present in Extrinsic STLC.

\vspace{2em}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \newterm{\annot{e}{A}} \pipe$ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl[e] \pipe \outr[e] \pipe$ \\
\qquad $\inl[e] \pipe \inr[e] \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$
  
\end{frame}

\begin{frame}{Declarative typing -- new rules}

\begin{center}
  $\infrule[Annot]{\typing{e}{A}}{\typing{\annot{e}{A}}{A}}$
\end{center}

\end{frame}

\newcommand{\fullcheck}[3]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3}
\renewcommand{\check}[2]{\fullcheck{\Gamma}{#1}{#2}}

\newcommand{\fullinfer}[3]{#1 \vdash #2 \mathcolor{red}{\Rightarrow} #3}
\newcommand{\infer}[2]{\fullinfer{\Gamma}{#1}{#2}}

\begin{frame}{Bidirectional typing -- basics}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma}}{\infer{x}{A}}$

  \vspace{2em}

  $\infrule[Annot]{\check{e}{A}}{\infer{\annot{e}{A}}{A}}$

  \vspace{2em}

  $\infrule[Sub]{\infer{e}{B} \quad \sidecond{A = B}}{\check{e}{A}}$
\end{center}

\end{frame}

\begin{frame}{Bidirectional typing -- type-directed rules}

\begin{center}
  $\infrule{\fullcheck{\extend{\Gamma}{x}{A}}{e}{B}}{\check{\fun{x}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\infer{f}{\Fun{A}{B}} \quad \check{a}{A}}{\infer{\app{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\check{a}{A} \quad \check{b}{B}}{\check{\pair{a}{b}}{\Prod{A}{B}}}$ \quad
  $\infrule{\infer{e}{\Prod{A}{B}}}{\infer{\outl[e]}{A}}$ \quad
  $\infrule{\infer{e}{\Prod{A}{B}}}{\infer{\outr[e]}{B}}$

  \vspace{2em}

  $\infrule{\check{e}{A}}{\check{\inl[e]}{\Sum{A}{B}}}$ \quad
  $\infrule{\check{e}{B}}{\check{\inr[e]}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\infer{e}{\Sum{A}{B}} \quad \check{f}{\Fun{A}{C}} \quad \check{g}{\Fun{B}{C}}}{\check{\case{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{}{\infer{\unit}{\Unit}}$ \quad
  $\infrule{\check{e}{\Empty}}{\check{\exfalso[e]}{A}}$
\end{center}

\end{frame}

\begin{frame}{Bidirectional typing -- additional rules}

\begin{center}
  $\infrule{\infer{e}{\Sum{A}{B}} \quad \infer{f}{\Fun{A}{C}} \quad \infer{g}{\Fun{B}{C}}}{\infer{\case{e}{f}{g}}{C}}$

\end{center}

\end{frame}

\begin{frame}{Metatheory}

Similarly to Extrinsic STLC, typing is not unique in Bidirectional STLC. This is because while we do have annotations in terms, we are not forced to use them. Therefore, we can check terms like $\fun{x}{x}$ with many types. However, inference is unique.

\end{frame}

\section{Hints}

\newcommand{\Hint}{\mathbf{?}}

\newcommand{\combinehints}[2]{#1 \sqcap #2}

\newcommand{\hintorder}[2]{#1 \sqsubseteq #2}

\begin{frame}{Hints}

Hints: \\
$H ::= \Hint \pipe \Fun{H_1}{H_2} \pipe \Prod{H_1}{H_2} \pipe \Sum{H_1}{H_2} \pipe \Unit \pipe \Empty$

\vspace{2em}

Intuitively, hints are partial types. They are built like types, except that there's one additional way to make hints: $\Hint$, which can be read as ``unknown'', ``hole'' or ``whatever''.

\vspace{2em}

We use the letter $H$ for hints. When we use letters like $A, B, C$ which usually stand for types, it means that the hint \textbf{is} a type, i.e. it doesn't contain any $\Hint$s.

\end{frame}

\begin{frame}{Combining hints}

\begin{center}
  $\combinehints{\Hint}{H} = H$ \\
  $\combinehints{H}{\Hint} = H$ \\
  $\combinehints{(\Fun{H_1}{H_2})}{(\Fun{H'_1}{H'_2})} = \Fun{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Prod{H_1}{H_2})}{(\Prod{H'_1}{H'_2})} = \Prod{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Sum{H_1}{H_2})}{(\Sum{H'_1}{H'_2})} = \Sum{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{\Unit}{\Unit} = \Unit$ \\
  $\combinehints{\Empty}{\Empty} = \Empty$
\end{center}

Intuitively, $\combinehints{}{}$ is a partial binary operation which combines two hints which share the same structure, possibly filling the $\Hint$s in the leaves with something more informative coming from the other argument. For hints which have incompatible structure (e.g. function hint and product hint) the result is undefined.

\end{frame}

\begin{frame}{Combining hints -- properties}

The operation $\combinehints{}{}$:

\begin{itemize}
  \item Is associative: $\combinehints{(\combinehints{H_1}{H_2})}{H_3} = \combinehints{H_1}{(\combinehints{H_2}{H_3})}$
  \item Is commutative, i.e. $\combinehints{H_1}{H_2} = \combinehints{H_2}{H_1}$
  \item Has neutral element: $\combinehints{\Hint}{H} = H = \combinehints{H}{\Hint}$
  \item Is idempotent, i.e. $\combinehints{H}{H} = H$.
\end{itemize}

\vspace{2em}

So, when $\combinehints{}{}$ happens to defined at all, it forms a commutative idempotent monoid. And as we all know, partial monoids are categories. So it seems hints form a thin groupoid... which they obviously do!

\end{frame}

\begin{frame}{Order on hints}

The operation $\combinehints{}{}$ induces an order on hints in the usual way: $\hintorder{H_1}{H_2} :\equiv (\combinehints{H_1}{H_2} = H_2)$.

\vspace{2em}

This order can be intuitively interpreted as an information increase: $\hintorder{H_1}{H_2}$ means that hint $H_2$ is more informative than $H_1$, but in a compatible way. In other words, $H_1$ and $H_2$ have the same structure, but some $\Hint$s from $H_1$ can be refined to something more informative in $H_2$.

\end{frame}

\begin{frame}{Order on hints -- explicitly}


\begin{center}
  $\infrule{}{\hintorder{\Hint}{H}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Fun{H_1}{H_2}}{\Fun{H'_1}{H'_2}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Prod{H_1}{H_2}}{\Prod{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Sum{H_1}{H_2}}{\Sum{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{}{\hintorder{\Unit}{\Unit}}$ \quad
  $\infrule{}{\hintorder{\Empty}{\Empty}}$
\end{center}

\end{frame}

\section{Hinting v1}

\newcommand{\fullhinting}[4]{#1 \vdash #2 \mathcolor{blue}{\Leftarrow} #3 \mathcolor{red}{\Rightarrow} #4}
\newcommand{\hinting}[3]{\fullhinting{\Gamma}{#1}{#2}{#3}}

\begin{frame}{Terms}

Note: red color marks differences from Bidirectional STLC.

\vspace{2em}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \termdiff{\annot{e}{H}} \pipe $ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl[e] \pipe \outr[e] \pipe$ \\
\qquad $\inl[e] \pipe \inr[e] \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Typing contexts assign types to variables, but annotations in terms are hints, not necessarily types.

\end{frame}

\begin{frame}{Notations}

$\ifun{x}{A}{e} :\equiv \annot{\fun{x}{e}}{\Fun{A}{\Hint}}$ \\
$\iinl{A}{e} :\equiv \annot{\inl{e}}{\Sum{\Hint}{A}}$ \\
$\iinr{A}{e} :\equiv \annot{\inr{e}}{\Sum{A}{\Hint}}$ \\
$\iexfalso{A}{e} :\equiv \annot{\exfalso{e}}{A}$

\end{frame}

\begin{frame}{Hinting -- basic rules}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma} \quad \sidecond{\hintorder{H}{A}}}{\hinting{x}{H}{A}}$

  \vspace{2em}

  $\infrule[Annot]{\hinting{e}{\combinehints{H_1}{H_2}}{A}}{\hinting{\annot{e}{H_1}}{H_2}{A}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- type-directed rules 1}

\begin{center}
  $\infrule{\sidecond{\combinehints{H}{(\Fun{\Hint}{\Hint})} = \Fun{A}{H'}} \quad \fullhinting{\extend{\Gamma}{x}{A}}{e}{H'}{B}}{\hinting{\fun{x}{e}}{H}{\Fun{A}{B}}}$

  \vspace{1em}

  $\infrule{\hinting{f}{\Fun{\Hint}{H}}{\Fun{H'}{B}} \quad \hinting{a}{H'}{A}}{\hinting{\app{f}{a}}{H}{B}}$

  \vspace{1em}

  $\infrule{\sidecond{\combinehints{H}{(\Prod{\Hint}{\Hint})} = \Prod{H_1}{H_2}} \quad \hinting{a}{H_1}{A} \quad \hinting{b}{H_2}{B}}{\hinting{\pair{a}{b}}{H}{\Prod{A}{B}}}$

  \vspace{1em}

  $\infrule{\hinting{e}{\Prod{H}{\Hint}}{\Prod{A}{B}}}{\hinting{\outl[e]}{H}{A}}$ \quad
  $\infrule{\hinting{e}{\Prod{H}{\Hint}}{\Prod{A}{B}}}{\hinting{\outr[e]}{H}{B}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- type-directed rules 2}

\begin{center}
  $\infrule{\sidecond{\combinehints{H}{(\Sum{\Hint}{\Hint})} = \Sum{H'}{B}} \quad \hinting{e}{H'}{A}}{\hinting{\inl[e]}{H}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\sidecond{\combinehints{H}{(\Sum{\Hint}{\Hint})} = \Sum{A}{H'}} \quad \hinting{e}{H'}{B}}{\hinting{\inr[e]}{H}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{\Sum{\Hint}{\Hint}}{\Sum{A}{B}} \quad \begin{array}{c} \hinting{f}{\Fun{A}{H}}{\Fun{A}{C}} \\ \hinting{g}{\Fun{B}{H}}{\Fun{B}{C}} \end{array}}{\hinting{\case{e}{f}{g}}{H}{C}}$

  \vspace{2em}

  $\infrule{\sidecond{\hintorder{H}{\Unit}}}{\hinting{\unit}{H}{\Unit}}$ \quad
  $\infrule{\hinting{e}{\Empty}{\Empty}}{\hinting{\exfalso[e]}{A}{A}}$
\end{center}

\end{frame}

\begin{frame}{Metatheory}

Similarly to extrinsic STLC, STLC with hints v1 does not enjoy uniqueness of typing. This is because we still can have terms like $\fun{x}{x}$ with hint $\Hint$, which can be typed with multiple types. However, if the hint is informative enough, then the type is unique. Moreover, every typable term can be given a hint which makes its type unique.

\end{frame}

\section{Hinting v2}

\newcommand{\hintfor}[2]{#1\ \triangle\ #2}

\begin{frame}{Hinting v2 -- hints for term constructors}

\begin{center}
  $\hintfor{H}{\fun{x}{e}} = \combinehints{H}{(\Fun{\Hint}{\Hint})}$ \\
  $\hintfor{H}{\pair{e_1}{e_2}} = \combinehints{H}{(\Prod{\Hint}{\Hint})}$ \\
  $\hintfor{H}{\inl[e]} = \combinehints{H}{(\Sum{\Hint}{\Hint})}$ \\
  $\hintfor{H}{\inr[e]} = \combinehints{H}{(\Sum{\Hint}{\Hint})}$ \\
  $\hintfor{H}{\unit} = \combinehints{H}{\Unit}$
\end{center}

\end{frame}

\begin{frame}{Hinting v2 -- basic rules}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma} \quad \sidecond{\hintorder{H}{A}}}{\hinting{x}{H}{A}}$

  \vspace{2em}

  $\infrule[Annot]{\hinting{e}{\combinehints{H_1}{H_2}}{A}}{\hinting{\annot{e}{H_1}}{H_2}{A}}$

  \vspace{2em}

  $\infrule[HintFor]{\sidecond{e\ \texttt{is a constructor}} \quad \sidecond{\hintfor{H}{e} = H'} \quad \hinting{e}{H'}{A}}{\hinting{e}{H}{A}}$
\end{center}
  
\end{frame}

\begin{frame}{Hinting v2 -- basic rules}
  
\begin{center}
  $\infrule{\fullhinting{\extend{\Gamma}{x}{A}}{e}{H}{B}}{\hinting{\fun{x}{e}}{\Fun{A}{H}}{\Fun{A}{B}}}$

  \vspace{1em}

  $\infrule{\hinting{f}{\Fun{\Hint}{H}}{\Fun{H'}{B}} \quad \hinting{a}{H'}{A}}{\hinting{\app{f}{a}}{H}{B}}$

  \vspace{1em}

  $\infrule{\hinting{a}{H_1}{A} \quad \hinting{b}{H_2}{B}}{\hinting{\pair{a}{b}}{\Prod{H_1}{H_2}}{\Prod{A}{B}}}$

  \vspace{1em}

  $\infrule{\hinting{e}{\Prod{H}{\Hint}}{\Prod{A}{B}}}{\hinting{\outl[e]}{H}{A}}$ \quad
  $\infrule{\hinting{e}{\Prod{H}{\Hint}}{\Prod{A}{B}}}{\hinting{\outr[e]}{H}{B}}$
\end{center}
  
\end{frame}
  
\begin{frame}{Hinting v2 -- type-directed rules}

\begin{center}
  $\infrule{\hinting{e}{H}{A}}{\hinting{\inl[e]}{\Sum{H}{B}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{H}{B}}{\hinting{\inr[e]}{\Sum{A}{H}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{\Sum{\Hint}{\Hint}}{\Sum{A}{B}} \quad \begin{array}{c} \hinting{f}{\Fun{A}{H}}{\Fun{A}{C}} \\ \hinting{g}{\Fun{B}{H}}{\Fun{B}{C}} \end{array}}{\hinting{\case{e}{f}{g}}{H}{C}}$

  \vspace{2em}

  $\infrule{}{\hinting{\unit}{\Unit}{\Unit}}$ \quad
  $\infrule{\hinting{e}{\Empty}{\Empty}}{\hinting{\exfalso[e]}{A}{A}}$
\end{center}

\end{frame}

\begin{frame}{Metatheory}

Metatheoretically, STLC with hints v2 is similar to v1.

\end{frame}

\end{document}