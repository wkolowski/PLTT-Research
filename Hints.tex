\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
  colorlinks = true,
  linkcolor = blue,
  urlcolor  = blue,
  citecolor = blue,
  anchorcolor = blue
}
\usepackage{Commands}

\usetheme{Darmstadt}

\title{Hinting\\A nice presentation of algorithmic typing}
\author{Wojciech Ko≈Çowski}
\date{}

\begin{document}

\frame{\titlepage}

\section{Hinting}

\begin{frame}{STLC with Hints}

STLC with Hints is a flavour of STLC inspired by Bidirectional STLC. The main insight behind it is that in Bidirectional STLC, we have a hard time deciding whether a rule should be in checking mode or in inference mode, so why not both? This way, we would have some input type that guides us, but also produce an output type, which is in some sense ``better''. This is a bit silly if we already have the correct type as input, but we can make this idea work by introducing hints, which are types with holes, and insisting that the input is not a type, but merely a hint.

\end{frame}

\begin{frame}{Hints}

$H ::= \Hole \pipe \Fun{H_1}{H_2} \pipe \Prod{H_1}{H_2} \pipe \Sum{H_1}{H_2} \pipe \Unit \pipe \Empty$

\vspace{2em}

Intuitively, hints are partial types. They are built like types, except that there's one additional constructor, $\Hole$, which can be read as ``hole'' or ``unknown''.

\vspace{2em}

We use the letter $H$ for hints. When we use letters like $A, B, C$ which usually stand in for types, it means that the hint \textbf{is} a type, i.e. it doesn't contain any $\Hole$s.

\end{frame}

\begin{frame}{Order on hints}

\begin{center}
  $\infrule{}{\hintorder{\Hole}{H}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Fun{H_1}{H_2}}{\Fun{H'_1}{H'_2}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Prod{H_1}{H_2}}{\Prod{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{\hintorder{H_1}{H_1'} \quad \hintorder{H_2}{H_2'}}{\hintorder{\Sum{H_1}{H_2}}{\Sum{H_1'}{H_2'}}}$

  \vspace{2em}

  $\infrule{}{\hintorder{\Unit}{\Unit}}$ \quad
  $\infrule{}{\hintorder{\Empty}{\Empty}}$
\end{center}

\end{frame}

\begin{frame}{Order on hints -- intuition}

The order can be intuitively interpreted as information increase: $\hintorder{H_1}{H_2}$ means that hint $H_2$ is more informative than $H_1$, but in a compatible way. In other words, $H_1$ and $H_2$ have the same structure, but some $\Hole$s from $H_1$ were possibly refined to something more informative in $H_2$.

\end{frame}

\begin{frame}{Combining hints}

\begin{center}
  $\combinehints{\Hole}{H} = H$ \\
  $\combinehints{H}{\Hole} = H$ \\
  $\combinehints{(\Fun{H_1}{H_2})}{(\Fun{H'_1}{H'_2})} = \Fun{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Prod{H_1}{H_2})}{(\Prod{H'_1}{H'_2})} = \Prod{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{(\Sum{H_1}{H_2})}{(\Sum{H'_1}{H'_2})} = \Sum{(\combinehints{H_1}{H'_1})}{(\combinehints{H_2}{H'_2})}$ \\
  $\combinehints{\Unit}{\Unit} = \Unit$ \\
  $\combinehints{\Empty}{\Empty} = \Empty$
\end{center}

The order on hints induces a partial operation $\combinehints{}{}$, which computes the least upper bound of two hints when it exists. Intuitively, $\combinehints{}{}$ combines two hints which share the same structure, filling the $\Hole$s in the leaves with something more informative coming from the other argument. For hints with incompatible structure the result is undefined.

\end{frame}

\begin{frame}{Combining hints -- properties}

If all relevant results are defined, then:

\begin{itemize}
  \item $\combinehints{(\combinehints{H_1}{H_2})}{H_3} = \combinehints{H_1}{(\combinehints{H_2}{H_3})}$
  \item $\combinehints{H_1}{H_2} = \combinehints{H_2}{H_1}$
  \item $\combinehints{\Hole}{H} = H = \combinehints{H}{\Hole}$
  \item $\combinehints{H}{H} = H$
\end{itemize}

\vspace{2em}

If $\combinehints{}{}$ were not partial, $(H, \combinehints{}{}, \Hole)$ would be a commutative idempotent monoid. But since it is partial, meh...

\end{frame}

\begin{frame}{Hints for term constructors}

\begin{center}
  $\hintfor{\fun{x}{e}} = \Fun{\Hole}{\Hole}$ \\
  $\hintfor{\pair{e_1}{e_2}} = \Prod{\Hole}{\Hole}$ \\
  $\hintfor{\inl{e}} = \Sum{\Hole}{\Hole}$ \\
  $\hintfor{\inr{e}} = \Sum{\Hole}{\Hole}$ \\
  $\hintfor{\unit} = \Unit$
\end{center}

\end{frame}

\begin{frame}{Terms}

Terms: \\
$e ::=$ \\
\qquad $x \pipe \termdiff{\annot{e}{H}} \pipe $ \\
\qquad $\fun{x}{e} \pipe \app{e_1}{e_2} \pipe$ \\
\qquad $\pair{e_1}{e_2} \pipe \outl{e} \pipe \outr{e} \pipe$ \\
\qquad $\inl{e} \pipe \inr{e} \pipe \case{e}{e_1}{e_2} \pipe$ \\
\qquad $\unit \pipe \exfalso{e}$

\vspace{2em}

Note: red color marks differences from Bidirectional STLC.

\vspace{2em}

Judgements: \\
$\fullhinting{\Gamma}{e}{H}{A}$ -- in context $\Gamma$, term $e$ checks with hint $H$ and infers type $A$

\end{frame}

\begin{frame}{Declarative typing -- differences}

\begin{center}
  $\infrule[Annot]{\typing{e}{A} \quad \sidecond{\hintorder{H}{A}}}{\typing{\annot{e}{H}}{A}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- basic rules}

\begin{center}
  $\infrule[Var]{\sidecond{(x : A) \in \Gamma} \quad \sidecond{\hintorder{H}{A}}}{\hinting{x}{H}{A}}$

  \vspace{2em}

  $\infrule[Annot]{\hinting{e}{\combinehints{H_1}{H_2}}{A}}{\hinting{\annot{e}{H_1}}{H_2}{A}}$

  \vspace{2em}

  $\infrule[Hole]{\hinting{e}{\hintfor{e}}{A} \quad \sidecond{e\ \texttt{constructor}}}{\hinting{e}{\Hole}{A}}$
\end{center}

\vspace{2em}

Note that the rule $\rulename{Hole}$ can only be applied once, because $\hintfor{e}$ can never be $\Hole$. After applying $\rulename{Hole}$, the only applicable rules are the type-directed ones.

\end{frame}

\begin{frame}{Hinting -- type-directed rules}

\begin{center}
  $\infrule{\fullhinting{\extend{\Gamma}{x}{A}}{e}{H}{B}}{\hinting{\fun{x}{e}}{\Fun{A}{H}}{\Fun{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{f}{\Fun{\Hole}{H}}{\Fun{A}{B}} \quad \hinting{a}{A}{A}}{\hinting{\app{f}{a}}{H}{B}}$

  \vspace{2em}

  $\infrule{\hinting{a}{H_A}{A} \quad \hinting{b}{H_B}{B}}{\hinting{\pair{a}{b}}{\Prod{H_A}{H_B}}{\Prod{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{\Prod{H}{\Hole}}{\Prod{A}{B}}}{\hinting{\outl{e}}{H}{A}}$ \quad
  $\infrule{\hinting{e}{\Prod{\Hole}{H}}{\Prod{A}{B}}}{\hinting{\outr{e}}{H}{B}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- type-directed rules}

\begin{center}
  $\infrule{\hinting{e}{H}{A}}{\hinting{\inl{e}}{\Sum{H}{B}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{H}{B}}{\hinting{\inr{e}}{\Sum{A}{H}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\hinting{e}{\Sum{\Hole}{\Hole}}{\Sum{A}{B}} \quad \begin{array}{c} \hinting{f}{\Fun{A}{H}}{\Fun{A}{C}} \\ \hinting{g}{\Fun{B}{C}}{\Fun{B}{C}} \end{array}}{\hinting{\case{e}{f}{g}}{H}{C}}$

  \vspace{2em}

  $\infrule{}{\hinting{\unit}{\Unit}{\Unit}}$ \quad
  $\infrule{\hinting{e}{\Empty}{\Empty}}{\hinting{\exfalso{e}}{A}{A}}$
\end{center}

\end{frame}

\begin{frame}{Hinting -- alternative rules}

\begin{center}
  $\infrule[AltApp]{\hinting{a}{\Hole}{H_A} \quad \hinting{f}{\Fun{H_A}{H_B}}{\Fun{A}{B}}}{\hinting{\app{f}{a}}{H_B}{B}}$

  \vspace{2em}

  $\infrule[AltCase]{\begin{array}{c} \hinting{f}{\Fun{\Hole}{H_C}}{\Fun{H_A}{H_C'}} \\ \hinting{g}{\Fun{\Hole}{H_C'}}{\Fun{H_B}{C}} \end{array} \quad \hinting{e}{\Sum{H_A}{H_B}}{\Sum{A}{B}}}{\hinting{\case{e}{f}{g}}{H_C}{C}}$
\end{center}

\vspace{2em}

We could have made some different choices. For application, we could try to infer the argument type first and then feed it to the function as a hint. For case, we could try to infer domains of the branches first, then feed these as hints when checking the discriminee.

\end{frame}

\begin{frame}{Notations and derived terms}

We can introduce some handy notations:

\begin{itemize}
  \item $\check{e}{A} :\equiv \hinting{e}{A}{A}$
  \item $\infer{e}{A} :\equiv \hinting{e}{\Hole}{A}$
\end{itemize}

We can embed Intrinsic STLC terms:

\begin{itemize}
  \item $\ifun{x}{A}{e} :\equiv \annot{\fun{x}{e}}{\Fun{A}{\Hole}}$ \\
  \item $\iinl{B}{e} :\equiv \annot{\inl{e}}{\Sum{\Hole}{B}}$ \\
  \item $\iinr{A}{e} :\equiv \annot{\inr{e}}{\Sum{A}{\Hole}}$ \\
  \item $\iexfalso{A}{e} :\equiv \annot{\exfalso{e}}{A}$
\end{itemize}

We can also embed Dual Intrinsic STLC terms:

\begin{itemize}
  \item $\iapp{A}{f}{a} :\equiv \app{\annot{f}{\Fun{A}{\Hole}}}{a}$
  \item $\ioutl{B}{e} :\equiv \outl{\annot{e}{\Prod{\Hole}{B}}}$
  \item $\ioutr{A}{e} :\equiv \outr{\annot{e}{\Prod{A}{\Hole}}}$
  \item $\icase{A}{B}{e}{f}{g} :\equiv \case{\annot{e}{\Sum{A}{B}}}{f}{g}$
\end{itemize}

\end{frame}

\begin{frame}{Rules for derived terms}

\begin{center}
  $\infrule{\fullinfer{\extend{\Gamma}{x}{A}}{e}{B}}{\infer{\ifun{x}{A}{e}}{\Fun{A}{B}}}$ \quad
  $\infrule{\check{f}{\Fun{A}{B}} \quad \check{a}{A}}{\check{\iapp{A}{f}{a}}{B}}$

  \vspace{2em}

  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutl{B}{e}}{A}}$ \enspace
  $\infrule{\check{e}{\Prod{A}{B}}}{\check{\ioutr{A}{e}}{B}}$

  \vspace{2em}

  $\infrule{\infer{e}{A}}{\infer{\iinl{B}{e}}{\Sum{A}{B}}}$ \quad
  $\infrule{\infer{e}{B}}{\infer{\iinr{A}{e}}{\Sum{A}{B}}}$

  \vspace{2em}

  $\infrule{\check{e}{\Sum{A}{B}} \quad \check{f}{\Fun{A}{C}} \quad \check{g}{\Fun{B}{C}}}{\check{\icase{A}{B}{e}{f}{g}}{C}}$

  \vspace{2em}

  $\infrule{\infer{e}{\Empty}}{\infer{\iexfalso{A}{e}}{A}}$
\end{center}

\end{frame}

\newcommand{\fulltermorder}[3]{#1 \vdash #2 \sqsubseteq #3}
%\newcommand{\termorder}[2]{\fulltermorder{\Gamma}{#1}{#2}}
\newcommand{\termorder}[2]{#1 \sqsubseteq #2}

\begin{frame}{Information order on terms}

The order on hints induces an order on terms: it is the smallest relation which preserves term constructors and subsumes hint ordering on annotated terms.

\vspace{2em}

\begin{center}
  $\infrule{\termorder{e_1}{e_2} \quad \hintorder{H_1}{H_2}}{\termorder{\annot{e_1}{H_1}}{\annot{e_2}{H_2}}}$
\end{center}

\end{frame}

\begin{frame}{Information order on terms}

\begin{center}
  $\infrule{}{\termorder{x}{x}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\fun{x}{e_1}}{\fun{x}{e_2}}}$ \quad
  $\infrule{\termorder{f_1}{f_2} \quad \termorder{a_1}{a_2}}{\termorder{\app{f_1}{a_1}}{\app{f_2}{a_2}}}$

  \vspace{2em}

  $\infrule{\termorder{a_1}{a_2} \quad \termorder{b_1}{b_2}}{\termorder{\pair{a_1}{b_1}}{\pair{a_2}{b_2}}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\outl{e_1}}{\outl{e_2}}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\outl{e_1}}{\outr{e_2}}}$

  \vspace{2em}

  $\infrule{\termorder{e_1}{e_2}}{\termorder{\inl{e_1}}{\inl{e_2}}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\inr{e_1}}{\inr{e_2}}}$

  \vspace{2em}

  $\infrule{\termorder{e_1}{e_2} \quad \termorder{f_1}{f_2} \quad \termorder{g_1}{g_2}}{\termorder{\case{e_1}{f_1}{g_1}}{\case{e_2}{f_2}{g_2}}}$

  \vspace{2em}

  $\infrule{}{\termorder{\unit}{\unit}}$ \quad
  $\infrule{\termorder{e_1}{e_2}}{\termorder{\exfalso{e_1}}{\exfalso{e_2}}}$
\end{center}

\end{frame}

\begin{frame}{Metatheory 1}

If $\fullhinting{\Gamma}{e}{H}{A}$ then:

\begin{itemize}
  \item (Soundness) $\fulltyping{\Gamma}{e}{A}$ (proof: induction)
  \item (Compatibility) $\hintorder{H}{A}$ (proof: induction)
  \item (Squeeze) If $\hintorder{H}{H'}$ and $\hintorder{H'}{A}$, then $\fullhinting{\Gamma}{e}{H'}{A}$ (proof: induction)
  \item (Upper bound) If $\fullhinting{\Gamma}{e}{H'}{A}$, then $\fullhinting{\Gamma}{e}{\combinehints{H}{H'}}{A}$ (proof: follows from the above)
  \item (Decidability) For $\Gamma, e, H$ it is decidable whether there exists $A$ such that $\fullhinting{\Gamma}{e}{H}{A}$ (proof: the rules are literally the algorithm)
  \item (Minimality) There exists $\hintorder{H'}{H}$ such that $\fullhinting{\Gamma}{e}{H'}{A}$ and for all $H'' \sqsubset H'$ it is not the case that $\fullhinting{\Gamma}{e}{H''}{A}$.
\end{itemize}

\end{frame}

\begin{frame}{Metatheory 2}

If $\fulltyping{\Gamma}{e}{A}$, then:

\begin{itemize}
  \item (Annotability) There exists $e'$ such that $\termorder{e}{e'}$ and $\fullhinting{\Gamma}{e'}{A}{A}$
  \item (Minimal annotability) There exists $e'$ such that $\termorder{e}{e'}$ and $\fullhinting{\Gamma}{e'}{A}{A}$ and for all $e''$ such that $\termorder{e}{e''}$ and $\termorder{e''}{e'}$ it is not the case that $\fullhinting{\Gamma}{e''}{A}{A}$
  \item There exist $\termorder{e}{e_1}$ and $\hintorder{H_1}{A}$ such that $\fullhinting{\Gamma}{e_1}{H_1}{A}$ and for all $e \sqsubseteq e_2 \sqsubseteq e_1$ and $H \sqsubseteq H' \sqsubseteq A$ it is not the case that $\fullhinting{\Gamma}{e_2}{H_2}{A}$
\end{itemize}

\end{frame}

\begin{frame}{(Non)uniqueness of typing}

Similarly to Extrinsic STLC, STLC with Hints does not enjoy uniqueness of typing. This is because we still can have terms like $\fun{x}{x}$ with hint $\Hole$, which can be typed with any type of the form $\Fun{A}{A}$. However, if the hint is informative enough, then the type is unique. Moreover, every typable term can be given a hint which makes its type unique.

\end{frame}

\end{document}